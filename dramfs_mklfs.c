// Program to create littlefs image comprising of input files/dirs
//
// Bandhav Veluri
// 03-07-2019

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "lfs.h"
#include <bd/lfs_rambd.h>
#include "dramfs_util.h"

// Main file system struct
lfs_t lfs;

// LFS configuration
struct lfs_config lfs_cfg = {
    // block device operations: lfs_bd.h
    .read  = lfs_rambd_read,
    .prog  = lfs_rambd_prog,
    .erase = lfs_rambd_erase,
    .sync  = lfs_rambd_sync,

    // block device default configuration
    .read_size   = 32,
    .prog_size   = 32,
    .block_size  = 0,
    .block_count = 0,
    .cache_size  = 32,
    .lookahead_size = 32,
    .block_cycles = 500
};

int main(int argc, char *argv[]) {
  int block_size;
  int block_count;

  if(argc < 3) {
    printf("Usage: dramfs_mklfs <block_size> <block_count> [input file(s)/dir(s)]\n");
    return -1;
  }

  block_size = atoi(argv[1]);
  block_count = atoi(argv[2]);

  //+------------------------------------------------------
  //| Allocate memory for building Little FS image
  //+------------------------------------------------------

  // memory allocation for lfs
  lfs_cfg.context = (char *) malloc(sizeof(lfs_rambd_t));

  // configure the size
  lfs_cfg.block_size = block_size;
  lfs_cfg.block_count = block_count;

  if(lfs_rambd_create(&lfs_cfg) < 0) {
    printf("LFS create error\n");
    return -1;
  }

  // format the fs
  if(lfs_format(&lfs, &lfs_cfg) < 0) {
    printf("LFS format error\n");
    return -1;
  }

  // mount the file system
  if(lfs_mount(&lfs, &lfs_cfg) < 0) {
    printf("LFS mount error\n");
    return -1;
  }

  //+-------------------------------------------------------
  //| Create stdin, stdout and stderr files in the littlefs
  //+-------------------------------------------------------
    
  lfs_file_t lfs_stdin, lfs_stdout, lfs_stderr;

  // Create stdio files
  lfs_file_open(&lfs, &lfs_stdin, "stdin", LFS_O_WRONLY | LFS_O_CREAT);
  lfs_file_open(&lfs, &lfs_stdout, "stdout", LFS_O_WRONLY | LFS_O_CREAT);
  lfs_file_open(&lfs, &lfs_stderr, "stderr", LFS_O_WRONLY | LFS_O_CREAT);

  // Close stdio files
  lfs_file_close(&lfs, &lfs_stdin);
  lfs_file_close(&lfs, &lfs_stdout);
  lfs_file_close(&lfs, &lfs_stderr);


  //+-------------------------------------------------------
  //| Copy input files/dirs to LFS image
  //+-------------------------------------------------------

  for(int i = 3; i < argc; i++) {
    if(lfs_cp(argv[i], &lfs) < 0)
      return -1;
  }

  // Unmount lfs
  if(lfs_unmount(&lfs) < 0){
    printf("LFS unmounting error\n");
    return -1;
  }

  //+------------------------------------------------------
  //| Print the LFS image as a C array
  //+------------------------------------------------------

  printf("// Newlib File System Initialization\n");
  printf("//\n");
  printf("// Autogenerated by dramfs_mkfs utility\n");
  printf("\n");
  printf("#include <sys/types.h>\n");
  printf("#include <machine/lfs.h>\n");
  printf("#include <machine/lfs_rambd.h>\n");
  printf("\n");

  printf( "// LFS configuration\n"
          "struct lfs_config dramfs_fs_cfg = {\n"
          "    // block device operations: lfs_bd.h\n"
          "    .read  = lfs_rambd_read,\n"
          "    .prog  = lfs_rambd_prog,\n"
          "    .erase = lfs_rambd_erase,\n"
          "    .sync  = lfs_rambd_sync,\n"
          "\n"
          "    // block device default configuration\n"
          "    .read_size   = 32,\n"
          "    .prog_size   = 32,\n"
          "    .block_size  = %d,\n"
          "    .block_count = %d,\n"
          "    .lookahead_size = 32,\n"
          "    .block_cycles = 500\n"
          "};\n\n", block_size, block_count);

  printf("lfs_t dramfs_fs;\n");

  printf("uint8_t lfs_mem[] = {\n");
  
  // dump fs memory to stdout in C array format
  lfs_rambd_t *bd = lfs_cfg.context;
  for(int i=0; i < block_size*block_count; i++) {
    printf("0x%0x", bd->buffer[i]);

    if(i != (block_size*block_count) - 1)
      putchar(',');

    putchar('\n');
  }

  printf("};");

  return 0;
}
